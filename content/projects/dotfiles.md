---
title: "dotfiles"
url: df
date: 2024-04-21T19:55:27.205+0300
publishDate: 2024-09-20T13:05:27.193+0300

brief: "my mayhem of system & software configs" 
link: https://github.com/ktnlvr/dotfiles
---

## What are dotfiles?

"Dotfiles" is a general name used to refer to configurations and system setting. It comes from the fact that most of them are hidden files prefixed with a dot, hence the name. Managing them is always ~~a pain~~ an adventure. 

## What does it solve?

All the config files are software-specific. Neovim has different configuration to alacritty, which has a different configuration to i3, but all of them follow a similar pattern: living in the `~/.config` directory.

A common approach is having a git repository inside the `.config`, having all of your data there. This is perfectly valid, I actually used to do that before. However, issues begin when an app requires a non-standard config location. Case and point - `zsh`. This shell stores its configuration in `$HOME/.zshrc` (like most other shells), so having a config repo no longer works.

Of course, one could store their `.zshrc` in `.config` and source it, but that's kinda combersome and doesn't scale too well.

Symlinks are a natural choice, but how would one organize and automate them? Where would they even lead?

## How does it work?

Symlink targets live in a separate folder that mimics the structure of `$HOME`. All required files are symlinked from the actual `$HOME` into this directory.

GNU `stow`[^stow] automates the symlink generation. `stow` is simple: when ran in a directory, it creates symlinks to all files inside it in the parent directory. Imagine the following `$HOME` directory:

```
-- The actual configs
.dotfiles/
  .zshrc
  .config/
    i3/
      config
    nvim/
      init.lua

-- Symlinks generated by GNU stow
.zshrc        -> .dotfiles/.zshrc
.config/
  i3/
    config    -> .dotfiles/.config/i3/config
  nvim/
    init.lua  -> .dotfiles/.config

-- The rest of the $HOME is intact
```

## How to install?

The `install.sh` is in the root of the project, but can be done with the `curl`/`wget` command in [`README.md`](https://github.com/ktnlvr/dotfiles/?tab=readme-ov-file#installation).

## How does it treat my existing system?

Stow markets itself as stable and safe[^stow-safe], which it seems to be true. The program was first created in 1993, so it is almost certainly more robust than my `install.sh`.

Before running it will check that both required dependencies are installed (`stow` and `git`). It isn't too critical, but helps avoid cryptic error messages.

One could possibly worry that stow will override their existing configurations. Luckily, when ran with the `--adopt` option, all the configuration files that already exist will be copied into the `.dotfiles` directory overriding the downloaded config. This flag is the only destructivee one, since if you don't have your downloaded configs in a git repo, the changes will be lost. Be careful!

In case some of the files are already existent in the place of symlinks, `stow` will issue a warning for each and not procede.

One defensive measure is updating instead of reinstalling. If someone tries to install my dotfiles, instead of reapplying the installation the script simply pulls the latest version from the main branch.

Otherwise, if something goes very wrong all commands have early exits. It won't try and `stow` a non-existent directory. Generally, the script is rather safe.

## What did you try?

**NixOS.** Yeah, no. The language got in the way too much. I couldn't get used to the syntax. Setting up a quick environment felt like a chore. Maybe I'm just too dense for the PhD-induced greatness. Rolling it to 1000+ auto-scaling production machines can be a valid usecase. Managing my laptop was not.

## When does it fail?

Managing system configs is something I am yet to discover how to properly do. I like using `doas`, but every time I set up a new machine I have to edit the `doas.conf` and I add a plain `permit kitten as root`. 

Installing software is also outside the scope of the dotfiles. I love it when I can run a script and roll out a fresh battle-ready system. Sometimes that also includes installing the right software.

A trivial solution might be having a pythonic `requirements.txt` with all the packages I'll ever want. Though some of them are missing on different distributions[^debian-nvim-missing]. If I go distro hopping again, I'll to manage that. Versioning the packages is also a pain.

## So, what gives?

Not sure. Try it if you need to roll out a system fast. Or want to test my workflow.

[^stow]: [GNU `stow`](https://www.gnu.org/software/stow/) "a symlink farm manager" (whatever that is) 
[^stow-safe]: "substantially simpler and safer", "stow will never delete any files, directories, or links", source: [`man`](https://linux.die.net/man/8/stow)
[^debian-nvim-missing]: The [Inky Editor](https://github.com/inkle/inky) is packaged in [AUR](https://aur.archlinux.org/packages/inky) for Arch but is entirely missing on Debian.
